<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mark3 Realtime Kernel: Getting Started With The Mark3 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mark3 Realtime Kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_s_t_a_r_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting Started With The <a class="el" href="namespace_mark3.html">Mark3</a> API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="START0"></a>
Kernel Setup</h1>
<p>This section details the process of defining threads, initializing the kernel, and adding threads to the scheduler.</p>
<p>If you're at all familiar with real-time operating systems, then these setup and initialization steps should be familiar. I've tried very hard to ensure that as much of the heavy lifting is hidden from the user, so that only the bare minimum of calls are required to get things started.</p>
<p>The examples presented in this chapter are real, working examples taken from the ATmega328p port.</p>
<p>First, you'll need to create the necessary data structures and functions for the threads:</p><ol type="1">
<li>Create a Thread object for all of the "root" or "initial" tasks.</li>
<li>Allocate stacks for each of the Threads</li>
<li>Define an entry-point function for each Thread</li>
</ol>
<p>This is shown in the example code below:</p>
<div class="fragment"><div class="line"><span class="comment">//---------------------------------------------------------------------------</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">thread.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="kernel_8h.html">kernel.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">//1) Create a thread object for all of the &quot;root&quot; or &quot;initial&quot; tasks</span></div><div class="line"><span class="keyword">static</span> Thread AppThread;</div><div class="line"><span class="keyword">static</span> Thread IdleThread;</div><div class="line"></div><div class="line"><span class="comment">//2) Allocate stacks for each thread</span></div><div class="line"><span class="preprocessor">#define STACK_SIZE_APP      (192)</span></div><div class="line"><span class="preprocessor">#define STACK_SIZE_IDLE     (128)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="portcfg_8h.html#a7bee6ac5affaf1f013a9d9de75054223">K_WORD</a> awAppStack[STACK_SIZE_APP];</div><div class="line"><span class="keyword">static</span> <a class="code" href="portcfg_8h.html#a7bee6ac5affaf1f013a9d9de75054223">K_WORD</a> awIdleStack[STACK_SIZE_IDLE];</div><div class="line"></div><div class="line"><span class="comment">//3) Define entry point functions for each thread</span></div><div class="line"><span class="keywordtype">void</span> AppThread(<span class="keywordtype">void</span>);</div><div class="line"><span class="keywordtype">void</span> IdleThread(<span class="keywordtype">void</span>);</div></div><!-- fragment --><p>Next, we'll need to add the required kernel initialization code to main. This consists of running the Kernel's init routine, initializing all of the threads we defined, adding the threads to the scheduler, and finally calling Kernel::Start(), which transfers control of the system to the RTOS.</p>
<p>These steps are illustrated in the following example.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">//1) Initialize the kernel prior to use</span></div><div class="line">    Kernel::Init();             <span class="comment">// MUST be before other kernel ops</span></div><div class="line"></div><div class="line">    <span class="comment">//2) Initialize all of the threads we&#39;ve defined</span></div><div class="line">    AppThread.Init( awAppStack,     <span class="comment">// Pointer to the stack</span></div><div class="line">                    STACK_SIZE_APP,     <span class="comment">// Size of the stack</span></div><div class="line">                    1,          <span class="comment">// Thread priority</span></div><div class="line">                    (<span class="keywordtype">void</span>*)AppEntry,    <span class="comment">// Entry function</span></div><div class="line">                    <span class="keyword">nullptr</span> );          <span class="comment">// Entry function argument</span></div><div class="line"></div><div class="line">    IdleThread.Init( awIdleStack,       <span class="comment">// Pointer to the stack</span></div><div class="line">                     STACK_SIZE_IDLE,   <span class="comment">// Size of the stack</span></div><div class="line">                     0,         <span class="comment">// Thread priority</span></div><div class="line">                     (<span class="keywordtype">void</span>*)IdleEntry,  <span class="comment">// Entry function</span></div><div class="line">                     <span class="keyword">nullptr</span> );     <span class="comment">// Entry function argument</span></div><div class="line"></div><div class="line">    <span class="comment">//3) Add the threads to the scheduler</span></div><div class="line">    AppThread.Start();          <span class="comment">// Actively schedule the threads</span></div><div class="line">    IdleThread.Start();</div><div class="line"></div><div class="line">    <span class="comment">//4) Give control of the system to the kernel</span></div><div class="line">    Kernel::Start();            <span class="comment">// Start the kernel!</span></div><div class="line">}</div></div><!-- fragment --><p>Not much to it, is there? There are a few noteworthy points in this code, though.</p>
<p>In order for the kernel to work properly, a system must always contain an idle thread; that is, a thread at priority level 0 that never blocks. This thread is responsible for performing any of the low-level power management on the CPU in order to maximize battery life in an embedded device. The idle thread must also never block, and it must never exit. Either of these operations will cause undefined behavior in the system.</p>
<p>The App thread is at a priority level greater-than 0. This ensures that as long as the App thread has something useful to do, it will be given control of the CPU. In this case, if the app thread blocks, control will be given back to the Idle thread, which will put the CPU into a power-saving mode until an interrupt occurs.</p>
<p>Stack sizes must be large enough to accommodate not only the requirements of the threads, but also the requirements of interrupts - up to the maximum interrupt-nesting level used. Stack overflows are super-easy to run into in an embedded system; if you encounter strange and unexplained behavior in your code, chances are good that one of your threads is blowing its stack.</p>
<h1><a class="anchor" id="THREADS"></a>
Threads</h1>
<p><a class="el" href="namespace_mark3.html">Mark3</a> Threads act as independent tasks in the system. While they share the same address-space, global data, device-drivers, and system peripherals, each thread has its own set of CPU registers and stack, collectively known as the thread's <b>context</b>. The context is what allows the RTOS kernel to rapidly switch between threads at a high rate, giving the illusion that multiple things are happening in a system, when really, only one thread is executing at a time.</p>
<h2><a class="anchor" id="TH_SETUP"></a>
Thread Setup</h2>
<p>Each instance of the Thread class represents a thread, its stack, its CPU context, and all of the state and metadata maintained by the kernel. Before a Thread will be scheduled to run, it must first be initialized with the necessary configuration data.</p>
<p>The Init function gives the user the opportunity to set the stack, stack size, thread priority, entry-point function, entry-function argument, and round-robin time quantum:</p>
<p>Thread stacks are pointers to blobs of memory (usually char arrays) carved out of the system's address space. Each thread must have a stack defined that's large enough to handle not only the requirements of local variables in the thread's code path, but also the maximum depth of the ISR stack.</p>
<p>Priorities should be chosen carefully such that the shortest tasks with the most strict determinism requirements are executed first - and are thus located in the highest priorities. Tasks that take the longest to execute (and require the least degree of responsiveness) must occupy the lower thread priorities. The idle thread must be the only thread occupying the lowest priority level.</p>
<p>The thread quantum only aplies when there are multiple threads in the ready queue at the same priority level. This interval is used to kick-off a timer that will cycle execution between the threads in the priority list so that they each get a fair chance to execute.</p>
<p>The entry function is the function that the kernel calls first when the thread instance is first started. Entry functions have at most one argument - a pointer to a data-object specified by the user during initialization.</p>
<p>An example thread initailization is shown below:</p>
<div class="fragment"><div class="line">Thread clMyThread;</div><div class="line"><a class="code" href="portcfg_8h.html#a7bee6ac5affaf1f013a9d9de75054223">K_WORD</a> awStack[192];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> AppEntry(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Do something!</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">{</div><div class="line">    clMyThread.Init(awStack,     <span class="comment">// Pointer to the stack to use by this thread</span></div><div class="line">                    <span class="keyword">sizeof</span>(awStack),             <span class="comment">// Size of the stack in bytes</span></div><div class="line">                    1,       <span class="comment">// Thread priority (0 = idle, 7 = max)</span></div><div class="line">                    (<span class="keywordtype">void</span>*)AppEntry, <span class="comment">// Function where the thread starts executing</span></div><div class="line">                    <span class="keyword">nullptr</span> );          <span class="comment">// Argument passed into the entry function</span></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Once a thread has been initialized, it can be added to the scheduler by calling:</p>
<div class="fragment"><div class="line">clMyThread.Start();</div></div><!-- fragment --><p>The thread will be placed into the Scheduler's queue at the designated priority, where it will wait its turn for execution.</p>
<h2><a class="anchor" id="TH_ENTRY"></a>
Entry Functions</h2>
<p><a class="el" href="namespace_mark3.html">Mark3</a> Threads should not run-to-completion - they should execute as infinite loops that perform a series of tasks, appropriately partitioned to provide the responsiveness characteristics desired in the system.</p>
<p>The most basic Thread loop is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Thread( <span class="keywordtype">void</span> *param )</div><div class="line">{</div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Do Something</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Threads can interact with eachother in the system by means of synchronization objects (Semaphore), mutual-exclusion objects (Mutex), Inter-process messaging (MessageQueue), and timers (Timer).</p>
<p>Threads can suspend their own execution for a predetermined period of time by using the static Thread::Sleep() method. Calling this will block the Thread's executin until the amount of time specified has ellapsed. Upon expiry, the thread will be placed back into the ready queue for its priority level, where it awaits its next turn to run.</p>
<h1><a class="anchor" id="TIMERS"></a>
Timers</h1>
<p>Timer objects are used to trigger callback events periodic or on a one-shot (alarm) basis.</p>
<p>While extremely simple to use, they provide one of the most powerful execution contexts in the system. The timer callbacks execute from within a timer thread, as a result of a semaphore posted in a timer interrupt. Timer callbacks are executed from a high-priority thread &ndash; typically at the highest priority thread in the system. Care must be taken to ensure that timer callbacks execute as quickly as possible to minimize the impact of processing on the throughput of tasks in the system. Wherever possible, heavy-lifting should be deferred to lower-priroity threads by way of semaphores or messages.</p>
<p>Below is an example showing how to start a periodic system timer which will trigger every second:</p>
<div class="fragment"><div class="line">{</div><div class="line">    Timer clTimer;</div><div class="line">    clTimer.Init();</div><div class="line"></div><div class="line">    clTimer.Start( 1000,              </div><div class="line">                 1,                   </div><div class="line">                 MyCallback,          </div><div class="line">                 (<span class="keywordtype">void</span>*)&amp;my_data );   </div><div class="line"></div><div class="line">    ... <span class="comment">// Keep doing work in the thread</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Callback function, executed from the timer-expiry context.</span></div><div class="line"><span class="keywordtype">void</span> MyCallBack( Thread *pclOwner_, <span class="keywordtype">void</span> *pvData_ )</div><div class="line">{</div><div class="line">    LED.Flash(); <span class="comment">// Flash an LED.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="SEM"></a>
Semaphores</h1>
<p>Semaphores are used to synchronized execution of threads based on the availability (and quantity) of application-specific resources in the system. They are extremely useful for solving producer-consumer problems, and are the method-of-choice for creating efficient, low latency systems, where ISRs post semaphores that are handled from within the context of individual threads. (Yes, Semaphores can be posted - but not pended - from the interrupt context).</p>
<p>The following is an example of the producer-consumer usage of a binary semaphore:</p>
<div class="fragment"><div class="line">Semaphore clSemaphore; <span class="comment">// Declare a semaphore shared between a producer and a consumer thread.</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Producer()</div><div class="line">{</div><div class="line">    clSemaphore.Init(0, 1);  </div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Do some work, create something to be consumed</span></div><div class="line"></div><div class="line">        <span class="comment">// Post a semaphore, allowing another thread to consume the data</span></div><div class="line">        clSemaphore.Post();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Consumer()</div><div class="line">{</div><div class="line">    <span class="comment">// Assumes semaphore initialized before use...</span></div><div class="line">    While(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Wait for new data from the producer thread</span></div><div class="line">        clSemaphore.Pend();</div><div class="line"></div><div class="line">        <span class="comment">// Consume the data!</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>And an example of using semaphores from the ISR context to perform event- driven processing.</p>
<div class="fragment"><div class="line">Semaphore clSemaphore;</div><div class="line"></div><div class="line">__interrupt__ MyISR()</div><div class="line">{</div><div class="line">    clSemaphore.Post(); <span class="comment">// Post the interrupt.  Lightweight when uncontested.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyThread()</div><div class="line">{</div><div class="line">    clSemaphore.Init(0, 1); <span class="comment">// Ensure this is initialized before the MyISR interrupt is enabled.</span></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Wait until we get notification from the interrupt</span></div><div class="line">        clSemaphore.Pend();</div><div class="line"></div><div class="line">        <span class="comment">// Interrupt has fired, do the necessary work in this thread&#39;s context</span></div><div class="line">        HeavyLifting();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="MUT"></a>
Mutexes</h1>
<p>Mutexes (Mutual exclusion objects) are provided as a means of creating "protected sections" around a particular resource, allowing for access of these objects to be serialized. Only one thread can hold the mutex at a time - other threads have to wait until the region is released by the owner thread before they can take their turn operating on the protected resource. Note that mutexes can only be owned by threads - they are not available to other contexts (i.e. interrupts). Calling the mutex APIs from an interrupt will cause catastrophic system failures.</p>
<p>Note that these objects are also not recursive- that is, the owner thread can not attempt to claim a mutex more than once.</p>
<p>Prioritiy inheritence is provided with these objects as a means to avoid prioritiy inversions. Whenever a thread at a priority than the mutex owner blocks on a mutex, the priority of the current thread is boosted to the highest-priority waiter to ensure that other tasks at intermediate priorities cannot artificically prevent progress from being made.</p>
<p>Mutex objects are very easy to use, as there are only three operations supported: Initialize, Claim and Release. An example is shown below.</p>
<div class="fragment"><div class="line">Mutex clMutex;  <span class="comment">// Create a mutex globally.</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Init()</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize the mutex before use.</span></div><div class="line">    clMutex.Init();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Some function called from a thread</span></div><div class="line"><span class="keywordtype">void</span> Thread1Function()</div><div class="line">{</div><div class="line">    clMutex.Claim();</div><div class="line"></div><div class="line">    <span class="comment">// Once the mutex is owned, no other thread can</span></div><div class="line">    <span class="comment">// enter a block protect by the same mutex</span></div><div class="line"></div><div class="line">    my_protected_resource.do_something();</div><div class="line">    my_protected_resource.do_something_else();</div><div class="line"></div><div class="line">    clMutex.Release();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Some function called from another thread</span></div><div class="line"><span class="keywordtype">void</span> Thread2Function()</div><div class="line">{</div><div class="line">    clMutex.Claim();</div><div class="line"></div><div class="line">    <span class="comment">// Once the mutex is owned, no other thread can</span></div><div class="line">    <span class="comment">// enter a block protect by the same mutex</span></div><div class="line"></div><div class="line">    my_protected_resource.do_something();</div><div class="line">    my_protected_resource.do_different_things();</div><div class="line"></div><div class="line">    clMutex.Release();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="EVF"></a>
Event Flags</h1>
<p>Event Flags are another synchronization object, conceptually similar to a semaphore.</p>
<p>Unlike a semaphore, however, the condition on which threads are unblocked is determined by a more complex set of rules. Each Event Flag object contains a 16-bit field, and threads block, waiting for combinations of bits within this field to become set.</p>
<p>A thread can wait on any pattern of bits from this field to be set, and any number of threads can wait on any number of different patterns. Threads can wait on a single bit, multiple bits, or bits from within a subset of bits within the field.</p>
<p>As a result, setting a single value in the flag can result in any number of threads becoming unblocked simultaneously. This mechanism is extremely powerful, allowing for all sorts of complex, yet efficient, thread synchronization schemes that can be created using a single shared object.</p>
<p>Note that Event Flags can be set from interrupts, but you cannot wait on an event flag from within an interrupt.</p>
<p>Examples demonstrating the use of event flags are shown below.</p>
<div class="fragment"><div class="line"><span class="comment">// Simple example showing a thread blocking on a multiple bits in the</span></div><div class="line"><span class="comment">// fields within an event flag.</span></div><div class="line"></div><div class="line">EventFlag clEventFlag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    ...</div><div class="line">    clEventFlag.Init(); <span class="comment">// Initialize event flag prior to use</span></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyInterrupt()</div><div class="line">{</div><div class="line">    <span class="comment">// Some interrupt corresponds to event 0x0020</span></div><div class="line">    clEventFlag.Set(0x0020);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyThreadFunc()</div><div class="line">{</div><div class="line">    ...</div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        ...</div><div class="line">        uint16_t u16WakeCondition;</div><div class="line"></div><div class="line">        <span class="comment">// Allow this thread to block on multiple flags</span></div><div class="line">        u16WakeCondition = clEventFlag.Wait(0x00FF, EventFlagOperation::Any_Set);</div><div class="line"></div><div class="line">        <span class="comment">// Clear the event condition that caused the thread to wake (in this case,</span></div><div class="line">        <span class="comment">// u16WakeCondtion will equal 0x20 when triggered from the interrupt above)</span></div><div class="line">        clEventFlag.Clear(u16WakeCondition);</div><div class="line"></div><div class="line">        <span class="comment">// &lt;do something&gt;</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="MSG"></a>
Messages</h1>
<p>Sending messages between threads is the key means of synchronizing access to data, and the primary mechanism to perform asynchronous data processing operations.</p>
<p>Sending a message consists of the following operations:</p>
<ul>
<li>Obtain a Message object from the global message pool</li>
<li>Set the message data and event fields</li>
<li>Send the message to the destination message queue</li>
</ul>
<p>While receiving a message consists of the following steps:</p>
<ul>
<li>Wait for a messages in the destination message queue</li>
<li>Process the message data</li>
<li>Return the message back to the global message pool</li>
</ul>
<p>These operations, and the various data objects involved are discussed in more detail in the following section.</p>
<h2><a class="anchor" id="MSGO"></a>
Message Objects</h2>
<p>Message objects are used to communicate arbitrary data between threads in a safe and synchronous way.</p>
<p>The message object consists of an event code field and a data field. The event code is used to provide context to the message object, while the data field (essentially a void * data pointer) is used to provide a payload of data corresponding to the particular event.</p>
<p>Access to these fields is marshalled by accessors - the transmitting thread uses the SetData() and SetCode() methods to seed the data, while the receiving thread uses the GetData() and GetCode() methods to retrieve it.</p>
<p>By providing the data as a void data pointer instead of a fixed-size message, we achieve an unprecedented measure of simplicity and flexibility. Data can be either statically or dynamically allocated, and sized appropriately for the event without having to format and reformat data by both sending and receiving threads. The choices here are left to the user - and the kernel doesn't get in the way of efficiency.</p>
<p>It is worth noting that you can send messages to message queues from within ISR context. This helps maintain consistency, since the same APIs can be used to provide event-driven programming facilities throughout the whole of the OS.</p>
<h2><a class="anchor" id="MSGQ"></a>
Message Queues</h2>
<p>Message objects specify data with context, but do not specify where the messages will be sent. For this purpose we have a MessageQueue object. Sending an object to a message queue involves calling the MessageQueue::Send() method, passing in a pointer to the Message object as an argument.</p>
<p>When a message is sent to the queue, the first thread blocked on the queue (as a result of calling the MessageQueue Receive() method) will wake up, with a pointer to the Message object returned.</p>
<p>It's worth noting that multiple threads can block on the same message queue, providing a means for multiple threads to share work in parallel.</p>
<h2><a class="anchor" id="MSGQS"></a>
Messaging Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Message queue object shared between threads</span></div><div class="line">MessageQueue clMsgQ;</div><div class="line"></div><div class="line"><span class="comment">// Function that initializes the shared message queue</span></div><div class="line"><span class="keywordtype">void</span> MsgQInit()</div><div class="line">{</div><div class="line">    clMsgQ.Init();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Function called by one thread to send message data to</span></div><div class="line"><span class="comment">// another</span></div><div class="line"><span class="keywordtype">void</span> TxMessage()</div><div class="line">{</div><div class="line">    <span class="comment">// Get a message, initialize its data</span></div><div class="line">    Message *pclMesg = MyMessagePool.Pop();</div><div class="line"></div><div class="line">    pclMesg-&gt;SetCode(0xAB);</div><div class="line">    pclMesg-&gt;SetData((<span class="keywordtype">void</span>*)some_data);</div><div class="line"></div><div class="line">    <span class="comment">// Send the data to the message queue</span></div><div class="line">    clMsgQ.Send(pclMesg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Function called in the other thread to block until</span></div><div class="line"><span class="comment">// a message is received in the message queue.</span></div><div class="line"><span class="keywordtype">void</span> RxMessage()</div><div class="line">{</div><div class="line">    Message *pclMesg;</div><div class="line"></div><div class="line">    <span class="comment">// Block until we have a message in the queue</span></div><div class="line">    pclMesg = clMsgQ.Receive();</div><div class="line"></div><div class="line">    <span class="comment">// Do something with the data once the message is received</span></div><div class="line">    pclMesg-&gt;GetCode();</div><div class="line"></div><div class="line">    <span class="comment">// Free the message once we&#39;re done with it.</span></div><div class="line">    MyMessagePool.Push(pclMesg);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="MBX"></a>
Mailboxes</h1>
<p>Another form of IPC is provided by <a class="el" href="namespace_mark3.html">Mark3</a>, in the form of Mailboxes and Envelopes.</p>
<p>Mailboxes are similar to message queues in that they provide a synchronized interface by which data can be transmitted between threads.</p>
<p>Where Message Queues rely on linked lists of lightweight message objects (containing only message code and a void* data-pointer), which are inherently abstract, Mailboxes use a dedicated blob of memory, which is carved up into fixed-size chunks called Envelopes (defined by the user), which are sent and received. Unlike message queues, mailbox data is copied to and from the mailboxes dedicated pool.</p>
<p>Mailboxes also differ in that they provide not only a blocking "receive" call, but also a blocking "send" call, providing the opportunity for threads to block on "mailbox full" as well as "mailbox empty" conditions.</p>
<p>All send/receive APIs support an optional timeout parameter if the KERNEL_USE_TIMEOUTS option has been configured in <a class="el" href="mark3cfg_8h.html" title="Mark3 Kernel Configuration. ">mark3cfg.h</a></p>
<h2><a class="anchor" id="MBXE"></a>
Mailbox Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Create a mailbox object, and define a buffer that will be used to store the</span></div><div class="line"><span class="comment">// mailbox&#39; envelopes.</span></div><div class="line"><span class="keyword">static</span> Mailbox clMbox;</div><div class="line"><span class="keyword">static</span> uint8_t aucMBoxBuffer[128];</div><div class="line"></div><div class="line">...</div><div class="line">void InitMailbox(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize our mailbox, telling it to use our defined buffer for envelope</span></div><div class="line">    <span class="comment">// storage.  Pass in the size of the buffer, and set the size of each</span></div><div class="line">    <span class="comment">// envelope to 16 bytes.  This gives u16 a mailbox capacity of (128 / 16) = 8</span></div><div class="line">    <span class="comment">// envelopes.</span></div><div class="line">    clMbox.Init((<span class="keywordtype">void</span>*)aucMBoxBuffer, 128, 16);</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">void SendThread(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// Define a buffer that we&#39;ll eventually send to the</span></div><div class="line">    <span class="comment">// mailbox.  Note the size is the same as that of an</span></div><div class="line">    <span class="comment">// envelope.</span></div><div class="line">    uint8_t aucTxBuf[16];</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Copy some data into aucTxBuf, a 16-byte buffer, the</span></div><div class="line">        <span class="comment">// same size as a mailbox envelope.</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// Deliver the envelope (our buffer) into the mailbox</span></div><div class="line">        clMbox.Send((<span class="keywordtype">void</span>*)aucTxBuf);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">void RecvThred(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint8_t aucRxBuf[16];</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Wait until there&#39;s a message in our mailbox.  Once</span></div><div class="line">        <span class="comment">// there is a message, read it into our local buffer.</span></div><div class="line">        cmMbox.Receive((<span class="keywordtype">void</span>*)aucRxBuf);</div><div class="line"></div><div class="line">        <span class="comment">// Do something with the contents of aucRxBuf, which now</span></div><div class="line">        <span class="comment">// contains an envelope of data read from the mailbox.</span></div><div class="line">        ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="NTF"></a>
Notification Objects</h1>
<p>Notification objects are the most lightweight of all blocking objects supplied by <a class="el" href="namespace_mark3.html">Mark3</a>.</p>
<p>using this blocking primative, one or more threads wait for the notification object to be signalled by code elsewhere in the system (i.e. another thread or interrupt). Once the the notification has been signalled, all threads currently blocked on the object become unblocked.</p>
<h2><a class="anchor" id="NTFE"></a>
Notification Example</h2>
<div class="fragment"><div class="line"> NOTIFIER</div><div class="line"></div><div class="line"><span class="keyword">static</span> Notify clNotifier;</div><div class="line"></div><div class="line">...</div><div class="line">void MyThread(<span class="keywordtype">void</span> *unused_)</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize our notification object before use</span></div><div class="line">    clNotifier.Init();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Wait until our thread has been notified that it</span></div><div class="line">        <span class="comment">// can wake up.</span></div><div class="line">        clNotify.Wait();</div><div class="line"></div><div class="line">        ...</div><div class="line">        <span class="comment">// Thread has woken up now -- do something!</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line">void SignalCallback(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// Something in the system (interrupt, thread event, IPC,</span></div><div class="line">    <span class="comment">// etc.,) has called this function.  As a result, we need</span></div><div class="line">    <span class="comment">// our other thread to wake up.  Call the Notify object&#39;s</span></div><div class="line">    <span class="comment">// Signal() method to wake the thread up.  Note that this</span></div><div class="line">    <span class="comment">// will have no effect if the thread is not presently</span></div><div class="line">    <span class="comment">// blocked.</span></div><div class="line"></div><div class="line">    clNotify.Signal();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="CONDVAR"></a>
Condition Variables</h1>
<p>Condition Variables, implemented in <a class="el" href="namespace_mark3.html">Mark3</a> with the ConditionVariable class, provide an implementation of the classic Monitor pattern. This object allows a thread to wait for a specific condition to occur, claiming a shared lock once the condition is met. Threads may also choose to signal a single blocking thread to indicate a condition has changed, or broadcast condition changes to all waiting threads.</p>
<h2><a class="anchor" id="CONDVAREX"></a>
Condition Variable Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Define a condition variable object, a shared lock, and</span></div><div class="line"><span class="comment">// a piece of common data shared between threads to represent</span></div><div class="line"><span class="comment">// a condition.</span></div><div class="line"></div><div class="line"><span class="comment">// Assume Mutex and ConditionVariable are initialized</span></div><div class="line"><span class="comment">// prior to use.</span></div><div class="line"><span class="keyword">static</span> ConditionVariable clCondVar;</div><div class="line"><span class="keyword">static</span> Mutex clSharedLock;</div><div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> iCondition = 0;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void CondThread1(<span class="keywordtype">void</span> *unused_)</div><div class="line">{</div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Wait until</span></div><div class="line">        clCondVar.Wait(&amp;clSharedLock);</div><div class="line"></div><div class="line">        <span class="comment">// Only act on a specific condition</span></div><div class="line">        <span class="keywordflow">if</span> (iCondition == 1337) {</div><div class="line">            <span class="comment">// Do something</span></div><div class="line">        }</div><div class="line"></div><div class="line">        clSharedLock.Release();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> CondThread2(<span class="keywordtype">void</span> *unused_)</div><div class="line">{</div><div class="line">    <span class="comment">// Assume Mutex and ConditionVariable are initialized</span></div><div class="line">    <span class="comment">// prior to use.</span></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Wait until</span></div><div class="line">        clCondVar.Wait(&amp;clSharedLock);</div><div class="line"></div><div class="line">        <span class="comment">// Act on a *different* condition than the other thread</span></div><div class="line">        <span class="keywordflow">if</span> (iCondition == 5454) {</div><div class="line">            <span class="comment">// Do something</span></div><div class="line">        }</div><div class="line"></div><div class="line">        clSharedLock.Release();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> SignalThread(<span class="keywordtype">void</span>* unused)</div><div class="line">{</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <span class="comment">// Sleep for a while</span></div><div class="line">        Thread::Sleep(100);</div><div class="line"></div><div class="line">        <span class="comment">// Update the condition in a thread-safe manner</span></div><div class="line">        clSharedLock.Claim();</div><div class="line">        iCondition = 1337;</div><div class="line">        clSharedLock.Release();</div><div class="line"></div><div class="line">        <span class="comment">// Wake one thread to check for the updated condition</span></div><div class="line">        clCondVar.Signal();</div><div class="line"></div><div class="line">        <span class="comment">// Sleep for a while</span></div><div class="line">        Thread::Sleep(100);</div><div class="line"></div><div class="line">        <span class="comment">// Update the condition in a thread-safe manner</span></div><div class="line">        clSharedLock.Claim();</div><div class="line">        iCondition = 1337;</div><div class="line">        clSharedLock.Release();</div><div class="line"></div><div class="line">        <span class="comment">// Wake all threads to check for the updated condition</span></div><div class="line">        clCondVar.Broadcast();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="RWLOCKS"></a>
Reader-Write Locks</h1>
<p>Reader-Writer locks are provided in <a class="el" href="namespace_mark3.html">Mark3</a> to provide an efficient way for multiple threads to share concurrent, non-destructive access to a resource, while preventing concurrent destructive/non-destructive accesses. A single "writer" may hold the lock, or 1-or-more "readers" may hold the lock. In the case that readers hold the lock, writers will block until all readers have relinquished their access to the resource. In the case that a writer holds the lock, all other readers and writers must wait until the lock is relinquished.</p>
<h2><a class="anchor" id="RWLOCKEX"></a>
Reader-Write Lock Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> WriterTask(<span class="keywordtype">void</span>* param)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> pclRWLock = <span class="keyword">static_cast&lt;</span>ReaderWriterLock*<span class="keyword">&gt;</span>(param);</div><div class="line"></div><div class="line">    pclRWLock-&gt;AcquireWriter();</div><div class="line">    <span class="comment">// All other readers and writers will have to wait until</span></div><div class="line">    <span class="comment">// the lock is released.</span></div><div class="line">    iNumWrites++;</div><div class="line">    ...</div><div class="line">    pclRWLock-&gt;ReleaseWriter();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ReaderTask(<span class="keywordtype">void</span>* param)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> pclRWLock = <span class="keyword">static_cast&lt;</span>ReaderWriterLock*<span class="keyword">&gt;</span>(param);</div><div class="line"></div><div class="line">    pclRWLock-&gt;AcquireReader();</div><div class="line">    <span class="comment">// Any number of reader threads can also acquire the lock</span></div><div class="line">    <span class="comment">// without having to block, waiting for this task to release it.</span></div><div class="line">    <span class="comment">// Writers must block until all readers have released their references</span></div><div class="line">    <span class="comment">// to the lock.</span></div><div class="line">    iNumReads++;</div><div class="line">    ...</div><div class="line">    pclRWLock-&gt;ReleaseReader();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="SLP"></a>
Sleep</h1>
<p>There are instances where it may be necessary for a thread to poll a resource, or wait a specific amount of time before proceeding to operate on a peripheral or volatile piece of data.</p>
<p>While the Timer object is generally a better choice for performing time-sensitive operations (and certainly a better choice for periodic operations), the Thread::Sleep() method provides a convenient (and efficient) mechanism that allows for a thread to suspend its execution for a specified interval.</p>
<p>Note that when a thread is sleeping it is blocked, during which other threads can operate, or the system can enter its idle state.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> GetPeripheralData();</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> value;</div><div class="line">    <span class="comment">// The hardware manual for a peripheral specifies that</span></div><div class="line">    <span class="comment">// the &quot;foo()&quot; method will result in data being generated</span></div><div class="line">    <span class="comment">// that can be captured using the &quot;bar()&quot; method.</span></div><div class="line">    <span class="comment">// However, the value only becomes valid after 10ms</span></div><div class="line"></div><div class="line">    peripheral.foo();</div><div class="line">    Thread::Sleep(10);  <span class="comment">// Wait 10ms for data to become valid</span></div><div class="line">    value = peripheral.bar();</div><div class="line">    <span class="keywordflow">return</span> value;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="RR"></a>
Round-Robin Quantum</h1>
<p>Threads at the same thread priority are scheduled using a round-robin scheme. Each thread is given a timeslice (which can be configured) of which it shares time amongst ready threads in the group. Once a thread's timeslice has expired, the next thread in the priority group is chosen to run until its quantum has expired - the cycle continues over and over so long as each thread has work to be done.</p>
<p>By default, the round-robin interval is set at 4ms.</p>
<p>This value can be overridden by calling the thread's SetQuantum() with a new interval specified in milliseconds. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 7 2019 19:45:15 for Mark3 Realtime Kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
