<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mark3 Realtime Kernel: Mark3 Design Goals</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mark3 Realtime Kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_i_n_s_i_d_e_m_a_r_k3.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_mark3.html">Mark3</a> Design Goals </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="INSIDEOVERVIEW"></a>
Overview</h1>
<h2><a class="anchor" id="INSIDEOVERSERVICES"></a>
Services Provided by an RTOS Kernel</h2>
<p>At its lowest-levels, an operating system kernel is responsible for managing and scheduling resources within a system according to the application. In a typical thread-based RTOS, the resources involved is CPU time, and the kernel manages this by scheduling threads and timers. But capable RTOS kernels provide much more than just threading and timers.</p>
<p>In the following section, we discuss the <a class="el" href="namespace_mark3.html">Mark3</a> kernel architecture, all of its features, and a thorough discussion of how the pieces all work together to make an awesome RTOS kernel.</p>
<h2><a class="anchor" id="INSIDEOVERPRINCIPLES"></a>
Guiding Principles of Mark3</h2>
<p><a class="el" href="namespace_mark3.html">Mark3</a> was designed with a number of over-arching principles, coming from years of experience designing, implementing, refining, and experimenting with RTOS kernels. Through that process I not only discovered what features I wanted in an RTOS, but how I wanted to build those features to look, work, and “feel”. With that understanding, I started with a clean slate and began designing a new RTOS. <a class="el" href="namespace_mark3.html">Mark3</a> is the result of that process, and its design goals can be summarized in the following guiding principles.</p>
<h2><a class="anchor" id="INSIDEOVERBFC"></a>
Be feature competitive</h2>
<p>To truly be taken seriously as more than just a toy or educational tool, an RTOS needs to have a certain feature suite. While <a class="el" href="namespace_mark3.html">Mark3</a> isn't a clone of any existing RTOS, it should at least attempt parity with the most common software in its class.</p>
<p>Looking at its competitors, <a class="el" href="namespace_mark3.html">Mark3</a> as a kernel supports most, if not all of the compelling features found in modern RTOS kernels, including dynamic threads, dynamic timers, efficient message passing, and multiple types of synchronization primatives.</p>
<h2><a class="anchor" id="INSIDEOVERNED"></a>
No external dependencies, no new language features</h2>
<p>To maximize portability and promote adoption to new platforms, <a class="el" href="namespace_mark3.html">Mark3</a> is written in a widely supported subset of C++ that lends itself to embedded applications. It avoids RTTI, exceptions, templates, and libraries (C standard, STL, etc.), with all fundamental data structures and types implemented completely for use by the kernel. As a result, the portable parts of <a class="el" href="namespace_mark3.html">Mark3</a> should compile for any capable C++ toolchain.</p>
<h2><a class="anchor" id="INSIDEOVERHPA"></a>
Target the most popular hobbyist platforms available</h2>
<p>Realistically, this means supporting the various Arduino-compatible target CPUs, including AVR and ARM Cortex-M series microcontrollers. As a result, the current default target for <a class="el" href="namespace_mark3.html">Mark3</a> is the atmega328p, which has 32KB of flash and 2KB of RAM. All decisions regarding default features, code size, and performance need to take that target system into account.</p>
<p><a class="el" href="namespace_mark3.html">Mark3</a> integrates cleanly as a library into the Arduino IDE to support atmega328-based targets. Other AVR and Cortex-M targets can be supported using the port code provided in the source package.</p>
<h2><a class="anchor" id="INSIDEOVERMAXDET"></a>
Maximize determinism – but be pragmatic</h2>
<p>Guaranteeing deterministic and predictable behavior is tough to do in an embedded system, and often comes with a heavy price tag in either RAM or code-space. With <a class="el" href="namespace_mark3.html">Mark3</a>, we strive to keep the core kernel APIs and features as lightweight as possible, while avoiding algorithms that don't scale to large numbers of threads. We also achieve minimal latency by keeping interrupts enabled (operating out of the critical section) wherever possible.</p>
<p>In <a class="el" href="namespace_mark3.html">Mark3</a>, the most important parts of the kernel are fixed-time, including thread scheduling and context switching. Operations that are not fixed time can be characterized as a function of their dependent data data. For instances, the Mutex and Semaphore APIs operate in fixed time in the uncontested case, and execute in linear time for the contested case – where the speed of execution is dependent on the number of threads currently waiting on that object.</p>
<p>The caveat here is that while we want to minimize latency and time spent in critical sections, that has to be balanced against increases in code size, and uncontested-case performance.</p>
<h2><a class="anchor" id="INSIDEOVERENG"></a>
Apply engineering principles – and that means discipline, measurement and verification</h2>
<p>My previous RTOS, FunkOS, was designed to be very ad-hoc. The usage instructions were along the lines of “drag and drop the source files into your IDE and compile”. There was no regression/unit testing, no code size/speed profiling, and all documentation was done manually. It worked, but the process was a bit of a mess, and resulted in a lot of re-spins of the software, and a lot of time spent stepping through emulators to measure parameters.</p>
<p>We take a different approach in <a class="el" href="namespace_mark3.html">Mark3</a>. Here, we've designed not only the kernel-code, but the build system, unit tests, profiling code, documentation and reporting that supports the kernel. Each release is built and tested using automation in order to ensure quality and correctness, with supporting documentation containing all critical metrics. Only code that passes testing is submitted to the repos and public forums for distribution. These metrics can be traced from build-to-build to ensure that performance remains consistent from one drop to the next, and that no regressions are introduced by new/refactored code.</p>
<p>And while the kernel code can still be exported into an IDE directly, that takes place with the knowledge that the kernel code has already been rigorously tested and profiled. Exporting source in <a class="el" href="namespace_mark3.html">Mark3</a> is also supported by scripting to ensure reliable, reproducible results without the possibility for human-error.</p>
<h2><a class="anchor" id="INSIDEOVERFLAVR"></a>
Use Virtualization For Verification</h2>
<p><a class="el" href="namespace_mark3.html">Mark3</a> was designed to work with automated simulation tools as the primary means to validate changes to the kernel, due to the power and flexibility of automatic tests on virtual hardware. I was also intrigued by the thought of extending the virtual target to support functionality useful for a kernel, but not found on real hardware.</p>
<p>When the project was started, simavr was the tool of choice- however, its simulation was found to be incorrect compared to execution on a real MCU, and it did not provide the degree of extension that I desired for use with kernel development.</p>
<p>The flAVR AVR simulator was written to replace the dependency on that tool, and overcome those limitations. It also provides a GDB interface, as well as its own built-in debugger, profilers, and trace tools.</p>
<p>flAVR is hosted on sourceforge at <a href="http://www.sourceforge.net/projects/flavr/">http://www.sourceforge.net/projects/flavr/</a> . In its basic configuration, it builds with minimal external dependencies.</p>
<ul>
<li>On linux, it requires only pthreads.</li>
<li>On Windows, it rquires pthreads and ws2_32, both satisfied via MinGW.</li>
<li>Optional SDL builds for both targets (featuring graphics and simulated joystick input) can be built, and rely on libSDL.</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 7 2019 19:45:15 for Mark3 Realtime Kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
